---
title: "Communities Speak"
author: "Brendan Mapes (borrowed work)"
date: "11/11/2022"
output:
  html_document: default
  pdf_document: default
---


#Load data
```{r message=FALSE, warning=FALSE}
library(googledrive)
library(readxl)
library(tidyverse)
library(stringr)
library(haven)
library(rjson)
library(googlesheets4)
#source("functions/fixup.R")
source("functions/make_codebook.R")
source("default_setup.R")
files <- list.files("../data/processed", full.names = TRUE)
lapply(files[str_detect(files, "survey_codebook")], function(file) load(file, envir = .GlobalEnv))
mavr <- append(mavr, "q33_4")


#source("clean_data.R")
#setwd("~/communities_speak/sp22/code")
source("functions/clean_data.R")

gs4_found <- gs4_find()

# update name of survey
survey_id <- gs4_found %>% filter(str_detect(name, "individual_survey_F22_01092023"),
                                  #str_detect(name, "June"),
                                  !str_detect(name, "Copy")) %>% select(id, name)

survey2 <- read_sheet(survey_id$id, sheet = "Sheet1") %>%
  rename_all(stringr::str_to_lower) %>%
  rename(duration = "duration (in seconds)", order = "fl_56_do") %>%
  filter(row_number() > 1) %>%
  select(responseid, recordeddate, duration, userlanguage, source,
         gc, aid,
         distributionchannel, order, matches("q"),
         -q_language) %>%
  mutate_at(vars(-recordeddate), ~str_to_lower(as.character(.)))  %>%
  unnest(recordeddate) %>% distinct #%>%
  # update: can remove if we don't need to make this fix for eme
  #mutate(source = ifelse(is.na(aid), source, "eme"))


census <- gs4_found %>% filter(str_detect(name, "DECENNIALPL2020.P4-2022-05-24T145132b"))

census <- census %>% pull(id) %>%
  read_sheet(sheet = "table") %>%
  mutate(race = stringi::stri_trans_general(race, "latin-ascii") %>%
                   str_to_lower %>% str_replace(":|alone", "") %>% trimws) %>%
  filter(!is.na(cat)) %>% select(-cat) %>%
  arrange(race) %>%
  mutate(target = count/sum(count),
         label = c("indigenous american / first nations (including american indian or alaska native)",
                   "asian",
                   "black or african american",
                   "hispanic or latinx",
                   "native hawaiian or pacific islander",
                   "two or more races",
                   "other",
                   "white (non-hispanic or latino)"))

boroughs <- read_csv("../data/input/boroughs.csv") %>% distinct # question: why are there repeats for the same 

```
#Incorporate new "completion" criteria: at least one demographic question and at least one policy question answered
```{r}
survey2$q15[survey2$q15 == "null"] <- NA
survey2$q16[survey2$q16 == "null"] <- NA
survey2$q18[survey2$q18 == "null"] <- NA
survey2$q29[survey2$q29 == "null"] <- NA
survey2$q34[survey2$q34 == "null"] <- NA
survey2$q15[survey2$q15 == "NA"] <- NA
survey2$q16[survey2$q16 == "NA"] <- NA
survey2$q18[survey2$q18 == "NA"] <- NA
survey2$q29[survey2$q29 == "NA"] <- NA
survey2$q34[survey2$q34 == "NA"] <- NA
survey2$q39[survey2$q39 == "null"] <- NA
survey2$q40[survey2$q40 == "null"] <- NA
survey2$q41[survey2$q41 == "null"] <- NA
survey2$q42_1[survey2$q42_1 == "null"] <- NA
survey2$q43[survey2$q43 == "null"] <- NA
survey2$q44[survey2$q44 == "null"] <- NA
survey2$q45[survey2$q45 == "null"] <- NA
survey2$q46[survey2$q46 == "null"] <- NA
survey2$q47_1[survey2$q47_1 == "null"] <- NA
survey2$q48[survey2$q48 == "null"] <- NA
survey2$q49[survey2$q49 == "null"] <- NA
survey2$q50[survey2$q50 == "null"] <- NA
survey2$q51[survey2$q51 == "null"] <- NA
survey2$q52[survey2$q52 == "null"] <- NA
survey2$q53[survey2$q53 == "null"] <- NA
survey2$q54_1[survey2$q54_1 == "null"] <- NA







fully_complete <- survey2 %>% mutate(na_count = rowSums(is.na(select(., (c(15,16,18, 34, 29, 30, 31, 32, 33, 69, 70,71,72,73,74,75,76,77, 78, 79, 80, 81, 82, 83, 84)))))) %>% filter(na_count < 1) #
fully_complete <- fully_complete %>% mutate(modules_count = rowSums(is.na(select(., (c(99, 101,102,104, 110, 111, 112, 113, 116, 117, 118, 119, 120, 121, 122 )))))) %>% filter(modules_count < 8)




```


# Var Dictionary
Combine with codebook in order to easily rename columns in the cleaned dataset

S# Survey Questions Codebook

Get important metadata on each of the questions that facilitates wrangling

#Clean data
```{r}
clean_data <- function(df = final_clean2, col = NULL) {
  by_col <- lapply(setdiff(colnames(df), c("responseid", "recordeddate")), function(col) {
    #for (col in colnames(survey)[-1]) {
    index <- which(survey_codebook$q == col)
    values <- as.integer(unlist(stringr::str_split(survey_codebook$options[index], pattern = "[:punct:]")))
    tags <- unlist(str_split(survey_codebook$choices[index], "; "))
    
    recode_na <- any(str_detect(tags, "not applicable"))
    
    if(any(is.null(tags), is.na(recode_na))) {
      recode_na <- FALSE ##this is a list of either null or false...should it be true or false?
    }
    
    if(all.equal(values, c(1,2)) == TRUE) {
      df[[col]] <- 2 - as.integer(df[[col]]) #recoding responses to 0,1
      values <- (2 - values) #recoding answer choices column to reflect change above
      
      if(recode_na & all.equal(values, c(1,2)) == TRUE) {
        df[[col]][df[[col]] == -1] <- 2 ##unsure here...
        values[values == -1] <- 2
      }
    }
    
    named <- setNames(values, tags) %>% na.omit #re-mapping choices (text) to the re-coded choices (numbers)
    
    if(is.null(tags)) {
      named <- FALSE #where re-mapping didn't work, call those FALSE in named
    }
    
    
    if(col %in% c(likert, simple)) {
      out <- df[c("responseid", col)] %>%
        mutate_at(vars(col), ~labelled(as.integer(.), named)) ###leaving off here###
      
      # multiple answer  
    } else if(col %in% mavr){
      
      sym_col <- sym(col)
      out <- df[c("responseid", col)] %>%
        fastDummies::dummy_cols(col, split = ",", ignore_na = TRUE) %>%
        tidytext::unnest_tokens(output = !!sym_col, input = col, token = stringr::str_split,  pattern = ",") %>%
        mutate_at(col, ~factor(as.integer(.), levels = values, labels = tags)) %>%
        group_by(responseid) %>% mutate_at(col, ~paste(., collapse = ";")) %>%
        distinct %>% na_if(NA)
      
      
      # don't double count prefer not to answer
      if(any(str_detect(tags, "prefer not to answer"))) {
        pnta <- which(names(named) == "prefer not to answer")
        pnta_col <- paste(c(col, pnta), collapse = "_")
        out <- out %>% mutate_at(pnta_col,
                                 funs(ifelse(str_detect(!!sym_col, "prefer not to answer;|;prefer not to answer"),
                                             0, !!sym(pnta_col)))) %>%
          mutate_at(col, ~str_replace(., "prefer not to answer;|;prefer not to answer", ""))
      }
      
      # haven label dummies
      cols_to_label <- out %>% ungroup %>% select_if(is.numeric) %>% colnames
      relabelled <- lapply(cols_to_label, function(dummy){
        i <- as.integer(str_replace(dummy, paste0(col, "_"), ""))
        values <- c(0, 1)
        names(values) <- c(glue::glue("not '{tags[i]}'"), tags[i])
        #names(values) <- c(paste("not", tags[i]), tags[i])
        out %>% ungroup %>% transmute_at(dummy, ~labelled(as.integer(.), values))
      }) %>% reduce(bind_cols)
      
      out[cols_to_label] <- relabelled
      
      #r_zaiyctblk6t1z33
    } else if(all(!str_detect(df[[col]], "[:alpha:]|^[:digit:]{3}(\\-|\\.)[:digit:]{3}(\\-|\\.)[:digit:]{4}$"), na.rm = TRUE) & any(!is.na(df[[col]]))) {
      out <- df[c("responseid", col)] %>% mutate_at(vars(col), as.integer)
    } else {
      out <- df[c("responseid", col)]  
    }
    
     #print(paste(col, recode_na, sep = ": "))
    #}    
    return(out)
  })
  
  by_col %>% reduce(full_join, by = c("responseid"))
  
  }
```



#Calculate completion percentage, ignoring modules
```{r}
#survey3 <- rbind(survey2, survey)
#survey3 <- rbind(survey, survey2)
#str(survey2)
#str(survey)
#test_clean <- clean_data(survey)
#write_xlsx(survey_codebook_labelled, "C:/Users/brend/OneDrive/Desktop/communities-speak/repo/fa22/code/scl2.xlsx")
#scl <- read_xlsx("C:/Users/brend/OneDrive/Desktop/communities-speak/repo/fa22/code/scl.xlsx")
#this is a problem that needs fixed
final_clean <- final_clean2[c('responseid', 'recordeddate')] %>% left_join(clean_data(df = final_clean2)) %>%
  #filter(responseid == "r_1jthhnt6oyjloix") %>%
  # update if zipcode is no logner q3
  left_join(boroughs, by = c("q3" = "zip")) #%>%
  # fix the senior question by hand
  # update appropriately.  can remove if we add validation directly to qualtrics to prevent individuals from entering numbers greater than 15 or something.
  #mutate(q14_1 = ifelse((q14_1 >= 65), 1, q14_1))
#final_clean <- final_clean %>% mutate(q22_9 = 99, q24_7 = 99, q24_9 = 99, q28_6 = 99, "q57_-2" = 99, q39_9 = 99, q41_8 = 99, q43_6 = 99)
# update completion according too the appropriate questions and survey flow logic.
## this code calculates completion rate by
## 1. iterating through each response
## 2. removing questions that were not pertinent to the respondent
## 3. transforming the row into a binary indicating whether or not the response is missing
## 4. taking the mean value of the row
completion <- lapply(final_clean2$responseid, function(id) {
## for loop logic for problem solving individual responses.
## comment out the return command at the bottom to utilize the for loop.
## for(id in final_clean$responseid) {
  
  row <- final_clean2[final_clean2$responseid == id, ] %>%  select(-(245:301)) %>% select(contains("q")) %>% 
    select(!matches("_"), contains("q14"), contains("q33"), contains("q42"), q36_1, q33_1, q32_1, q31_1)
  
  
  # employment logic
  if(!str_detect(row$q16, "unemp") || is.na(row$q21)) { # respondents who didn't mark unemployed
    row <- row %>% select(-q21, -q21a)  ##leaving off here
  } else if(any(is.na(row$q21), labelled::to_factor(row$q21) != "yes")) {
    row <- row %>% select(-q21a)
  }
  
  # household with children logic
  if(sum(as.numeric(row$q14_3), as.numeric(row$q14_4), as.numeric(row$q14_5), na.rm = TRUE) == 0) { # respondents that don't have children
    row <- row %>% select(-q26, -q27, -q33_7)
  }# else if(str_detect(row$q39, "home") & !str_detect(row$q39, ";") | is.na(row$q39)) { # respondents that only selected home school
    #row <- row %>% select(-q44, -q46)
 # }
  
  # residence logic
  ## will need to disqualify respondents not just based on completion, but also...
  if(any(row$q1 == 0, is.na(row$q1))) { # goes to the end because it removes all the columns (can't test the other conditions)
    row <- row %>% select(q1)
  }
  
  completion <- round(mean(!is.na(row)), digits = 6)
  #print(id)
  return(completion)
}) %>% unlist

final_clean2$completion <- completion

# update the question numbers so that validity is calculated appropriately.
final_clean2 <- final_clean2 %>% mutate(q14_1 = as.numeric(q14_1), q14_2 = as.numeric(q14_2), q14_3 = as.numeric(q14_3), q14_4 = as.numeric(q14_4), q14_5 = as.numeric(q14_5)) %>% 
  mutate(test_response = if_any(everything(), str_detect, pattern = "^test$|beta_test")) %>%
  mutate(valid = case_when( #completion > 0.5 &   #add back in once defined
    q1 == 1 & q5 > 17 & !is.na(borough) ~ 1,
    TRUE ~ 0
  )) %>%
  mutate(
    source = ifelse(is.na(source), "communities speak", source),
    #valid = ifelse(is.na(test_response), valid, NA_integer_), #not yet defined ...update when definition comes -brendan
    
    # update the question number if changed
    hh_size = rowSums(across(starts_with("q14"))),
    #valid = ifelse(hh_size <= 20 | is.na(valid) | is.na(hh_size), valid, 0), #not yet defined ...update when definition comes -brendan
    # update the question number if changed
    # add one for people who responded that their age and not in that bracket 
    
    q14_1 = ifelse(q5 >= 65 & q14_1 == 0, 1, q14_1),
    q14_2 = ifelse(q5 >= 18 & q5 < 65 & q14_2 == 0, 1, q14_2)) %>%
  select(responseid, recordeddate, duration, userlanguage, source, aid, order, #completion, valid, test_response, (add these back in when defined)
          borough, starts_with("q"))
final_clean2$completion <- completion
hist(final_clean2$completion)
mean(!is.na(final_clean2$q1))
save(final_clean2, file = "../data/processed/cleaned.rdata")
write_csv(final_clean2, file = "../data/processed/cleaned.csv")
colMeans(is.na(survey))
colMeans(is.na(final_clean2))

final_clean2 %>%
  select(responseid, userlanguage, q4_6, q4_7) %>% na.omit() %>%
  filter(if_any(everything(), ~str_detect(., pattern = "^test$")))
```

#Wrangle data
```{r}
# update all question numbers appropriately if survey questions change in qualtrics
# update all created variable names if they change (must change this first in the labeling sheet)
# update any new definitions of old variables
# add any new variables here and to the labeling sheet

#bug fixing by Brendan - updating in excel above to save time
#final_clean <- bind_rows(final_clean2, final_clean)
final_clean2 <- final_clean2 %>% mutate(gc = 99, distributionchannel = 99)

wrangled <- final_clean2  %>% #mutate(completion = rowSums(!is.na(final_clean2))/ncol(final_clean2)) %>%
  # remove invalid responses
 # filter(valid == 1) %>%  #uncomment this once we decide what valid is
  #select(-test_response) %>% #uncomment this one too..see note directly above
  # make new variables
  mutate(
    #### location variables ####
    # create binary for all of the boroughs
    bronx_bi = labelled::to_character(borough) == "bronx",
    brooklyn_bi = labelled::to_character(borough) == "brooklyn",
    queens_bi = labelled::to_character(borough) == "queens",
    manhattan_bi = labelled::to_character(borough) == "manhattan", #added by Brendan
    staten_island_bi = labelled::to_character(borough) == "staten island", #added by Brendan
    #### transform binary variables ####  #add new variables that need binaries##
    across(c(q26, q27, q45, q51), ~ifelse(. == 3, NA_integer_, 2 - .), .names = "{col}_bi"),
    
    #### income variables ####
    # income change variables
    inc_neg = ifelse(q16 == 2, 1, 0),
    inc_pos = ifelse(q16 == 1, 1, 0),
    inc_same = ifelse(q16 == 3, 1, 0), #added by Brendan

    #inc_drop_med = q13 > median_inc & q14 <= median_inc, #not possible in new version
    #inc_drop_pov = q13 > poverty_line & q14 <= poverty_line,
    
    # income distribution before
    below_poverty_bi = ifelse(q15 == 1 | q15 == 2 | q15 == 3 & q14_2 == 1 & q14_3 + q14_4 + q14_5 >= 1 | q15 == 3 & q14_2 == 1 & q14_1 >= 1 | q15 == 3 & q14_2 > 1 & q14_3 + q14_4 + q14_5 == 0 | q15 == 3 & q14_2 > 1 & q14_1 == 0 | q15 == 4 & q14_2 == 1 & q14_1 >= 1 | q15 == 4 & q14_2  == 1 &  q14_3 + q14_4 + q14_5 + q14_1 >= 3 & q14_1 >= 1 | q15 == 4 & q14_2 == 1 &  q14_3 + q14_4 + q14_5 + q14_1 >= 4 & q14_3 + q14_4 + q14_5 >= 3 | q15 == 4 & q14_2 == 2 &  q14_3 + q14_4 + q14_5 + q14_1 >= 2 | q15 == 4 & q14_2 >= 3, 1, 0),
                           
                           
                           
    inc_dist = case_when(
      q15 <= poverty_line ~ 1, #these need updated to account for number of people in a household
      q15 <= median_inc ~ 2,
      TRUE ~ 3), # label them with haven
    
    #above or below median income before-hand
    #inc_ab_med_before = q13 > median_inc,  #not possible in new version
    #inc_be_med_before = q13 <= median_inc,
    
    #above or below median income afterward
    #inc_ab_med_after = q14 > median_inc, #not possible in new version
    #inc_be_med_after = q14 <= median_inc,
    
    #below poverty line before and after
    #inc_be_pov_before = q13 <= poverty_line, #not possible in new version
    #inc_be_pov_after = q14 <= poverty_line,
    
    # above median income both
    inc_ab_med = q15 > median_inc & q13 > median_inc,
    inc_be_med = q15 <= median_inc & q13 <= median_inc,
    
    #### employment variables ####
    wrk_in = str_detect(labelled::to_character(q19), "yes"),
    
    # work full-time; work part-time; freelance or consultant; gig worker (uber, lyft, instacart, etc.); small business owner; homemaker; student; retired; disabled; unemployed; other
    emp_status_before = case_when(
      str_detect(q17, "unemp") ~ "unemployed",
      str_detect(q17, "full|part|free|gig|small|home") ~ "employed",
      str_detect(q17, "student") ~ "student",
      str_detect(q17, ";") ~ "multiple_other",
      TRUE ~ q17), # students will be categorized
    
    emp_status_after = case_when(
      str_detect(q18, "unemp") ~ "unemployed",
      str_detect(q18, "full|part|free|gig|small|home") ~ "employed",
      str_detect(q18, "student") ~ "student",
      str_detect(q18, ";") ~ "multiple_other",
      TRUE ~ q18),
    
    emp_change = q17 != q18,
     
    
    emp_before_part_time = case_when(
      q17_9 == 0 & any(q17_1 == 1, q17_2 == 1, q17_3 == 1, q17_10 == 1) ~ 1,
      q17_9 == 1 ~ 0
    ),
    
    emp_after_part_time = case_when(
      q18_9 == 0 & any(q18_1 == 1, q18_2 == 1, q18_3 == 1, q18_10 == 1) ~ 1,
      q18_9 == 1 ~ 0
    ),
    #unemployed = emp_after == "unemployed", # newly unemployed # emp_un_after
    
    #### mental health variables ####
    ## q36_1 unable to control
    ## q36_2 confident about your ability
    ## q36_3 going your way
    ## q36_4 difficulties piling up
    
    across(c(q36_2, q36_3),
           ~labelled(5-.,5-attributes(final_clean2$q36_3)$labels)),
    across(c(q36_1, q36_4),
           ~labelled(.-1,attributes(final_clean2$q36_4)$labels-1)),
    stress_score = rowSums(across(starts_with("q36_"))),
    stress_bi = mean(stress_score, na.rm = TRUE) < stress_score,
    
    
    #### health variables ####
    ## q22_5 no insurance 
    ins_has = 1 - q29_5,
    
    #### covid variables ####
    ## q40 have your received the covid-19 booster?
    ## q38 tested positive?
    ## q43 concern over variants
    ## q39 vaccinated
    #boost_bi = str_detect(labelled::to_character(q39), "yes"), #no more booster question so removing -brendan
    #boost_plan = str_detect(labelled::to_character(q39), "i plan"),
    
    #posi_all = str_detect(labelled::to_character(q38), "yes"),#no more testing question so removing -brendan
    
    #vrnts_ve = q43 == 1, #no more variants question so removing -brendan
    #vrnts_con = q43 %in% c(1, 2),#no more variants question so removing -brendan
    
    #### household variables ####
    ## q5 = age
    decade = floor(as.numeric(q5)/10),
    
    hh_sn_65_bi = q14_1 >= 1, # fixed 
    hh_ch_6_17_bi = q14_3 >= 1,
    hh_ch_3_5_bi = q14_4 >= 1,
    hh_ch_0_2_bi = q14_5 >= 1,
    hh_ch_0_17_bi = if_any(c(q14_3, q14_4, q14_5), ~. >= 1),
    hh_ch_sn = if_all(c(hh_sn_65_bi, hh_ch_0_17_bi), ~. >= 1),
    #hh_ch_0_17_bi = q26_3 >=1 | q26_4 >=1,
    
    hh_size = rowSums(across(starts_with("q14"))),
    hh_ad_one = q14_1 + q14_2 == 1,
    
    # fix this third option: not applicable
    no_find_cc_bi = str_detect(labelled::to_character(q27), "no\\b"),
    # also need_Cc
    
    #### residence variables ####
    # fix this
    res_cat = labelled::to_character(q23),
    res_cat = case_when(
      str_detect(res_cat, "public") ~ 1,
      str_detect(res_cat, "owner") ~ 2,
      str_detect(res_cat, "renter") ~ 3,
      str_detect(res_cat, "not have") ~ 4
      ),
    
    #### education variables ####
    sch_level_cat = labelled::to_character(q12),
    sch_level_cat = case_when(
      str_detect(sch_level_cat, "high school|some college") ~ as.numeric(q12),
      str_detect(sch_level_cat, "bach|ass") ~ 4,
      str_detect(sch_level_cat, "doct|mast|prof") ~ 5
      ),
    
    sch_bach = ifelse(sch_level_cat <= 3, 0, 1),
    
    #### discrimination variables ####
    discrim_bi = q35 %in% c(1, 2),
    
    #### abuse or violence variables ####
    exp_ab_or_vi = str_detect(q34, "yes"),
    exp_ab_and_vi = str_detect(q34, "verbal abuse") & str_detect(q34, "physical violence"),
    
    #### concern variables ####
    ## q21_2 worried about running out of food
    ## q21_3 ran out of food
    ## q21_5 difficulty accessing cleaning supplies
    ## q21_6 difficulty accessing transportation
    ## q21_7 difficulty paying bills
    ## q21_8 difficulty paying rent
    ## q21_9 difficulty accessing housing
    ## q29 all concerns about child attending school

   #no longer asked att_con_num = as.integer(unlist(lapply(str_split(q30, ";"),
                                       #function(item) if(any(!is.na(item))) {unlist(length(item))} else {NA}))),

    # at least two concerns about insecurity
    #fin_unstable = q21_3 == 1 & q21_7 == 1 | q21_7 == 1 & q21_8 == 1 |
    #  q21_8 == 1 & q21_3 == 1,
    # q22_2 diff_worr - worried about running out of food
    # q22_3 diff_ran_out
    # q22_7 diff_bill
    # q22_8 diff_rent
    # worried about running out or ran out of food
    food_insec = if_any(c(q25_1, q24_1), ~.==1), #UPDATE CODEBOOK -brendan
    house_insec = if_any(c(q24_4, q25_4), ~.== 1),
    fin_insec = if_any(c(q24_1, q24_3, q24_4), ~.== 1),
    
    # accessing resources
    res_insec = if_any(c(q25_1, q25_2, q25_3, q25_4, q25_5), ~.==1),
    
    
    #### rating variables ####
    ## q33_3 = rate government city
    
    rate_gov_fed_bad = q31_1 > 3,
    rate_gov_sta_bad = q31_2 > 3,
    rate_gov_cit_bad = q31_3 > 3,
    
    rate_gov_all_good = if_all(starts_with("q31"), ~.<3),
    rate_gov_all_bad = if_all(starts_with("q31"), ~.>3),
    rate_gov_all_ave = round(rowMeans(6 - across(starts_with("q31"))), digits = 4),
    
    across(c(q32_4, q32_5, q32_6, q32_8, q32_9), ~ . < 3, .names = "{col}_good"),
    across(c(q32_4, q32_5, q32_6, q32_8, q32_9), ~ . > 3, .names = "{col}_bad"),
    
    
    #### access variables ####
    lr_fam = if_any(starts_with("q33_") & ends_with("_5"), ~.==1),
    lr_gov = if_any(starts_with("q33_") & ends_with("_3"), ~.==1),
    lr_fb = if_any(starts_with("q33_") & ends_with("_1"), ~.==1),
    lr_np = if_any(starts_with("q33_") & ends_with("_2"), ~.==1),
    
    #internet_lim = q24 != 1, # respondent has limited or no internet access
    #internet_acc = q24 %in% c(1, 2), #both of these no longer asked
    
    race_census = ifelse(q7 != "white (non-hispanic or latinx)", str_replace_all(q7,
                                  c(".*hispanic or latinx.*" = "hispanic or latinx",
                                    ".*;.*" = "two or more races",
                                    "prefer not to answer" = NA_character_)), "white (non-hispanic or latinx)"))

# naming survey varaibles

indeces <- which(survey_codebook_labelled$q %in% colnames(wrangled))
key <- survey_codebook_labelled$q[indeces]
value <- survey_codebook_labelled$full_name[indeces]

names(wrangled)[match(key, names(wrangled))] <- value

# naming q34
#indeces34 <- which(str_detect(survey_codebook_labelled$q, "34"))
#key34 <- survey_codebook_labelled$q[indeces34]
keyq_ <- colnames(wrangled)[str_detect(colnames(wrangled), "q[[:digit:]]{1,2}")]
key_split <- str_split(keyq_, "_(?=[[:alpha:]])")
pre <- unlist(lapply(key_split, first))
suf <- unlist(lapply(key_split, last))
#keyq <- str_replace(keyq_, "_[[:alpha:]]*$", "")
indecesq <- match(pre, survey_codebook_labelled$q)
valuesq <- survey_codebook_labelled$full_name[indecesq]
valuesq_ <- paste(valuesq, suf, sep = "_")
names(wrangled)[match(keyq_, names(wrangled))] <- valuesq_

# labeling
na_omit <- new_vars %>% na.omit()
to_label <- na_omit$var_name[na_omit$var_name %in% colnames(wrangled)]
new_vars_to_label <- lapply(to_label, function(col) {
  if(col %in% colnames(wrangled)) {
    index <- which(na_omit$var_name == col)
    values <- as.integer(unlist(stringr::str_split(na_omit$var_value[index], pattern = "[:punct:]")))
    tags <- unlist(str_split(na_omit$var_label[index], "; ?"))
    named <- setNames(values, tags)
    out <- wrangled[col] %>% mutate_at(vars(col), funs(labelled(as.integer(.), named)))
    return(out)
  }
  
}) %>% reduce(bind_cols)

dim_before <- dim(wrangled)

wrangled[to_label] <- new_vars_to_label

dim_after <- dim(wrangled)
all.equal(dim_before, dim_after)

which(duplicated(colnames(wrangled))== TRUE)
#fixing one hot encoding for baseline
names(wrangled)[44] <- "emp_before_ft"
names(wrangled)[45] <- "emp_before_pt"
names(wrangled)[46] <- "emp_before_fl"
names(wrangled)[47] <- "emp_before_sb"
names(wrangled)[48] <- "emp_before_st"
names(wrangled)[49] <- "emp_before_gig"
names(wrangled)[50] <- "emp_before_hm"
names(wrangled)[51] <- "emp_before_re"
names(wrangled)[52] <- "emp_before_other"
names(wrangled)[53] <- "emp_before_un"

names(wrangled)[56] <- "emp_after_ft"
names(wrangled)[57] <- "emp_after_pt"
names(wrangled)[58] <- "emp_after_fl"
names(wrangled)[59] <- "emp_after_gig"
names(wrangled)[60] <- "emp_after_sb"
names(wrangled)[61] <- "emp_after_st"
names(wrangled)[62] <- "emp_after_hm"
names(wrangled)[63] <- "emp_after_re"
names(wrangled)[64] <- "emp_after_other"
names(wrangled)[65] <- "emp_after_un"

names(wrangled)[70] <- "emp_reas_new"
names(wrangled)[74] <- "emp_reas_other"
names(wrangled)[77] <- "emp_reas_train"

names(wrangled)[86] <- "unemp_diff_den"
names(wrangled)[87] <- "unemp_diff_other"
names(wrangled)[88] <- "unemp_diff_no_need"
names(wrangled)[89] <- "unemp_diff_none"

names(wrangled)[98] <- "diff_afford_hc"
names(wrangled)[105] <- "diff_access_hc"
names(wrangled)[106] <- "diff_access_test"

names(wrangled)[122] <- "drive"
names(wrangled)[123] <- "taxi"
names(wrangled)[124] <- "carpool"
names(wrangled)[125] <- "public_bus"
names(wrangled)[126] <- "private_bus"
names(wrangled)[127] <- "subway"
names(wrangled)[128] <- "rail"
names(wrangled)[129] <- "ferry"
names(wrangled)[130] <- "bike"
names(wrangled)[131] <- "walk"
names(wrangled)[132] <- "other"
names(wrangled)[133] <- "trans_other_text"

names(wrangled)[151] <- "lr_stress_idk"  #NA vs "NA" might need investigated in this matrix
names(wrangled)[152] <- "lr_stress_ff"
names(wrangled)[153] <- "lr_stress_unions"
names(wrangled)[154] <- "lr_stress_NA"


names(wrangled)[160] <- "lr_trans_idk"
names(wrangled)[162] <- "lr_trans_NA"
names(wrangled)[163] <- "lr_trans_unions"

names(wrangled)[169] <- "lr_food_idk"
names(wrangled)[171] <- "lr_food_unions"
names(wrangled)[172] <- "lr_food_NA"

names(wrangled)[174] <- "lr_hc_fb"
names(wrangled)[175] <- "lr_hc_np"
names(wrangled)[176] <- "lr_hc_gov"
names(wrangled)[177] <- "lr_hc_emp"
names(wrangled)[179] <- "lr_hc_ff"
names(wrangled)[180] <- "lr_hc_idk"
names(wrangled)[178] <- "lr_hc_unions"
names(wrangled)[181] <- "lr_hc_NA"


names(wrangled)[187] <- "lr_util_idk"
names(wrangled)[188] <- "lr_util_ff"
names(wrangled)[189] <- "lr_util_unions"
names(wrangled)[190] <- "lr_util_NA"


names(wrangled)[191] <- "lr_cc"
names(wrangled)[196] <- "lr_cc_idk"
names(wrangled)[197] <- "lr_cc_ff"
names(wrangled)[198] <- "lr_cc_unions"
names(wrangled)[199] <- "lr_cc_NA"

names(wrangled)[200] <- "lr_ec"
names(wrangled)[205] <- "lr_ec_idk"
names(wrangled)[206] <- "lr_ec_ff"
names(wrangled)[207] <- "lr_ec_unions"
names(wrangled)[208] <- "lr_ec_NA"

names(wrangled)[243] <- "future_contact"

#end of baseline

#education module
names(wrangled)[257] <- "sch_ch_type_char"
names(wrangled)[259] <- "sch_ch_type_none"
names(wrangled)[264] <- "sch_ch_type_other"

names(wrangled)[277] <- "sch_ch_reas_other"
names(wrangled)[278] <- "sch_ch_reas_restr"
names(wrangled)[276] <- "sch_ch_reas_cov_safe"
names(wrangled)[275] <- "sch_ch_reas_phys_safe"

#safety module
names(wrangled)[290] <- "safe_reas_sub"

#binary-like questions may need recoded in safety module, depending on Aawanti's preference. Some have a third option other than yes/no, which throws off traditional 0:no, 1:yes coding strategy

#wrangled <- rename(wrangled[66] = NA)
#derived variables checkup
wrangled <- mutate(wrangled, manhattan_bi = ifelse(manhattan_bi== "TRUE", 1, 0)) %>% mutate(staten_island_bi = ifelse(staten_island_bi =="TRUE", 1, 0))



wrangled <- mutate(wrangled, inc_dist = ifelse(income == 1 | income == 2, 1, ifelse(income == 3, 2, 3)))
wrangled <- mutate(wrangled, inc_ab_med = ifelse(income == 4 | income == 5, 1, 0))
wrangled <- mutate(wrangled, inc_be_med = ifelse(income == 3 | income == 2 | income == 1, 1, 0))

wrangled <- mutate(wrangled, hh_ch_3_5_bi = ifelse(hh_ch_3_5 == 0, 0, 1))

wrangled <- mutate(wrangled, discrim_bi = ifelse(discrim == 1 | discrim == 2, 1, ifelse(discrim == 3, 0, NA)))

wrangled <- mutate(wrangled, food_insec = ifelse(diff_access_food == 1 | diff_afford_food == 1, 1, ifelse(diff_access_food == 0 & diff_afford_food == 0, 0, NA)))

wrangled <- mutate(wrangled, house_insec = ifelse(diff_access_hous == 1 | diff_afford_rent == 1, 1, ifelse(diff_access_hous == 0 & diff_afford_rent == 0, 0 , NA)))

wrangled <- mutate(wrangled, sev_food_insec = ifelse(food_insec == 1 & insecure_food_ran_out == 1 | food_insec == 1 & insecure_food_worr == 1, 1, ifelse(food_insec == 0 & insecure_food_ran_out == 0 & insecure_food_ran_out == 0, 0, NA)))

wrangled <- mutate(wrangled, sev_hous_insec = ifelse(house_insec == 1 & insecure_hous == 1 | house_insec == 1 & insecure_evict == 1, 1, ifelse(house_insec == 0 & insecure_hous == 0 & insecure_evict == 0, 0, NA)))

wrangled <- mutate(wrangled, rate_neigh_code_good = ifelse(rate_neigh_code_good == "TRUE", 1, ifelse(rate_neigh_code_good == "FALSE", 0, NA)))

wrangled <- mutate(wrangled, rate_neigh_code_bad = ifelse(rate_neigh_code_bad == "TRUE", 1, ifelse(rate_neigh_code_bad == "FALSE", 0, NA)))

wrangled <- mutate(wrangled, sch_sat_yes = ifelse(sch_sat == 3 | sch_sat == 4, 1, ifelse(sch_sat == 1 | sch_sat == 2 | sch_sat == 5, 0, NA)))

wrangled <- mutate(wrangled, sch_sat_no = ifelse(sch_sat == 1 | sch_sat == 2, 1, ifelse(sch_sat == 3 | sch_sat == 4 | sch_sat == 5, 0, NA)))

wrangled <- mutate(wrangled, safe_home_yes = ifelse(safe_home == 1 | safe_home == 2, 1, ifelse(safe_home == 3 | safe_home == 4 | safe_home == 5, 0, NA)))

wrangled <- mutate(wrangled, safe_home_no = ifelse(safe_home == 4 | safe_home == 5, 1, ifelse(safe_home == 3 | safe_home == 2 | safe_home == 1, 0, NA)))

wrangled <- mutate(wrangled, safe_work_no = ifelse(safe_work == 4 | safe_work == 5, 1, ifelse(safe_work == 3 | safe_work == 2 | safe_work == 1, 0, NA)))

wrangled <- mutate(wrangled, safe_work_yes = ifelse(safe_work == 1 | safe_work == 2, 1, ifelse(safe_work == 3 | safe_work == 4 | safe_work == 5, 0, NA)))

wrangled <- mutate(wrangled, safe_commute_no = ifelse(safe_commute == 4 | safe_commute == 5, 1, ifelse(safe_commute == 3 | safe_commute == 2 | safe_commute == 1, 0, NA)))

wrangled <- mutate(wrangled, safe_commute_yes = ifelse(safe_commute == 1 | safe_commute == 2, 1, ifelse(safe_commute == 3 | safe_commute == 4 | safe_commute == 5, 0, NA)))

wrangled <- mutate(wrangled, poldirect_comm_yes = ifelse(pol_approach == 1 & pol_local == 3 | pol_approach == 1 & pol_local == 4 | pol_approach == 1 & pol_local == 5, 1, ifelse(pol_approach == 0 | pol_local == 2 | pol_local == 1, 0, NA)))

wrangled <- mutate(wrangled, poldirect_comm_no = ifelse(pol_approach == 1 & pol_local == 1 | pol_approach == 1 & pol_local == 2, 1, ifelse(pol_approach == 0 | pol_local == 3 | pol_local == 4 | pol_local == 5, 0, NA)))

wrangled <- mutate(wrangled, pol_stop_rep_no = ifelse(pol_stop == 2 & pol_report == 3, 1, ifelse(pol_stop == 1 | pol_stop == 3 | pol_report == 1 | pol_report == 2, 0, NA)))

wrangled <- mutate(wrangled, pol_stop_rep_yes = ifelse(pol_stop == 2 & pol_report == 1, 1, ifelse(pol_stop == 1 | pol_stop == 3 | pol_report ==  2 | pol_report == 3, 0, NA)))

wrangled <- mutate(wrangled, pol_news_rep_yes = ifelse(news == 2 & pol_report == 1 | news == 1 & pol_report == 1, 1, ifelse(news == 3 | news == 4 | pol_report ==  2 | pol_report == 3, 0, NA)))

wrangled <- mutate(wrangled, pol_news_rep_no = ifelse(news == 2 & pol_report == 3 | news == 1 & pol_report == 3, 1, ifelse(news == 3 | news == 4 | pol_report ==  2 | pol_report == 1, 0, NA)))

which(colnames(wrangled) == "NA_idk")
#[1] 154 164 172 182 191 200


#add neighborhoods
wrangled$bronx <- wrangled$zip %>% recode("10453" = "Central Bronx", "10457" = "Central Bronx", "10460" = "Central Bronx", "10458" = "Bronx Park and Fordham", "10467" = "Bronx Park and Fordham", "10468" = "Bronx Park and Fordham", "10451" = "High Bridge and Morrisania", "10452" = "High Bridge and Morrisania", "10456"= "High Bridge and Morrisania", "10454" = "Hunts Point and Mott Haven", "10455" = "Hunts Point and Mott Haven", "10459" = "Hunts Point and Mott Haven", "10474" = "Hunts Point and Mott Haven", "10463" = "Kingsbridge and Riverdale", "10471" = "Kingsbridge and Riverdale", "10466" = "Northeast Bronx", "10469" = "Northeast Bronx", "10470" = "Northeast Bronx", "10475" = "Northeast Bronx", "10461" = "Southeast Bronx", "10462" = "Southeast Bronx", "10464" = "Southeast Bronx", "10465" = "Southeast Bronx", "10472" = "Southeast Bronx", "10473"= "Southeast Bronx")

wrangled$bk <- wrangled$zip %>% recode("11212" = "Central Brooklyn", "11213" = "Central Brooklyn", "11216" = "Central Brooklyn", "11233" = "Central Brooklyn", "11238" = "Central Brooklyn", "11209" = "Southwest Brooklyn", "11214" = "Southwest Brooklyn", "11228" = "Southwest Brooklyn", "11204" = "Borough Park", "11218" = "Borough Park", "11219" = "Borough Park", "11230" = "Borough Park", "11234" = "Canarsie and Flatlands", "11236" = "Canarsie and Flatlands", "11239" = "Canarsie and Flatlands", "11223" = "Southern Brooklyn", "11224" = "Southern Brooklyn", "11229" = "Southern Brooklyn", "11235" = "Southern Brooklyn", "11201" = "Northwest Brooklyn", "11205" = "Northwest Brooklyn", "11215" = "Northwest Brooklyn", "11217" = "Northwest Brooklyn", "11231" = "Northwest Brooklyn", "11203" = "Flatbush", "11210" = "Flatbush", "11225" = "Flatbush", "11226" = "Flatbush", "11207" = "East New York and New Lots", "11208" = "East New York and New Lots", "11211" = "Greenpoint", "11222" = "Greenpoint", "11220" = "Sunset Park", "11232" = "Sunset Park", "11206" = "Bushwick and Williamsburg", "11221" = "Bushwick and Williamsburg", "11237" = "Bushwick and Williamsburg")
                                                   
                                                   
wrangled$mh <- wrangled$zip %>% recode("10026" = "Central Harlem", "10027" = "Central Harlem", "10030" = "Central Harlem", "10037" = "Central Harlem", "10039" = "Central Harlem", "10001" = "Chelsea and Clinton", "10011" = "Chelsea and Clinton", "10018" = "Chelsea and Clinton", "10019" = "Chelsea and Clinton", "10020" = "Chelsea and Clinton", "10036" = "Chelsea and Clinton", "10029" = "East Harlem", "10035" = "East Harlem", "10010" = "Gramercy Park and Murray Hill", "10016" = "Gramercy Park and Murray Hill", "10017" = "Gramercy Park and Murray Hill", "10022" = "Gramercy Park and Murray Hill", "10012" = "Greenwich Village and Soho", "10013" = "Greenwich Village and Soho", "10014" = "Greenwich Village and Soho", "10004" = "Lower Manhattan", "10005" = "Lower Manhattan", "10006" = "Lower Manhattan", "10007" = "Lower Manhattan", "10038" = "Lower Manhattan", "10280" = "Lower Manhattan", "10002" = "Lower East Side", "10003" = "Lower East Side", "10009" = "Lower East Side", "10021" = "Upper East Side", "10028" = "Upper East Side", "10044" = "Upper East Side", "10065" = "Upper East Side", "10075" = "Upper East Side", "10128" = "Upper East Side", "10023" = "Upper West Side", "10024" = "Upper West Side", "10025" = "Upper West Side", "10031" = "Inwood and Washington Heights", "10032" = "Inwood and Washington Heights", "10033" = "Inwood and Washington Heights", "10034" = "Inwood and Washington Heights", "10040" = "Inwood and Washington Heights")
                                                   
wrangled$qu <- wrangled$zip %>% recode("11361" = "Northeast Queens", "11362" = "Northeast Queens", "11363" = "Northeast Queens", "11364" = "Northeast Queens", "11354" = "North Queens", "11355" = "North Queens", "11356" = "North Queens", "11357" = "North Queens", "11358" = "North Queens", "11359" = "North Queens", "11360" = "North Queens", "11365" = "Central Queens", "11366" = "Central Queens", "11367" = "Central Queens", "11412" = "Jamaica", "11423" = "Jamaica", "11432" = "Jamaica", "11433" = "Jamaica", "11434" = "Jamaica", "11435" = "Jamaica", "11436" = "Jamaica", "11101" = "Northwest Queens", "11102" = "Northwest Queens", "11103" = "Northwest Queens", "11104" = "Northwest Queens", "11105" = "Northwest Queens", "11106" = "Northwest Queens", "11374" = "West Central Queens", "11375" = "West Central Queens", "11379" = "West Central Queens", "11385" = "West Central Queens", "11691" = "Rockaways", "11692" = "Rockaways", "11693" = "Rockaways", "11694" = "Rockaways", "11695" = "Rockaways", "11697" = "Rockaways", "11004" = "Southeast Queens", "11005" = "Southeast Queens", "11411" = "Southeast Queens", "11413" = "Southeast Queens", "11422" = "Southeast Queens", "11426" = "Southeast Queens", "11427" = "Southeast Queens", "11428" = "Southeast Queens", "11429" = "Southeast Queens", "11414" = "Southwest Queens", "11415" = "Southwest Queens", "11416" = "Southwest Queens", "11417" = "Southwest Queens", "11418" = "Southwest Queens", "11419" = "Southwest Queens", "11420" = "Southwest Queens", "11421" = "Southwest Queens", "11368" = "West Queens", "11369" = "West Queens", "11370" = "West Queens", "11372" = "West Queens", "11373" = "West Queens", "11377" = "West Queens", "11378" = "West Queens")

wrangled$si <- wrangled$zip %>% recode("10302" = "Port Richmond", "10303" = "Port Richmond", "10310" = "Port Richmond", "10306" = "South Shore", "10307" = "South Shore", "10308" = "South Shore", "10309" = "South Shore", "10312" = "South Shore", "10301" = "Stapleton and St. George", "10304" = "Stapleton and St. George", "10305" = "Stapleton and St. George", "10314" = "Mid-Island")


wrangled <- wrangled %>% mutate(neighborhood = coalesce(bronx, bk, mh, qu, si))

#wrangled <- wrangled %>% mutate(drive = as.integer(ifelse(trans == 1, 1, 0))) %>% mutate(bus = as.integer(ifelse(trans == 2, 1, 0))) %>% mutate(pool = as.integer(ifelse(trans == 3, 1, 0))) %>% mutate(bike = as.integer(ifelse(trans == 4, 1, 0))) %>% mutate(scooter = as.integer(ifelse(trans == 5, 1, 0))) %>% mutate(subway = as.integer(ifelse(trans == 6, 1, 0))) %>% mutate(walk = as.integer(ifelse(trans == 7, 1, 0)))

```

#borough must be completed as well...had to go to wrangled for this
```{r}
completed_subset <- subset(wrangled,responseid %in% fully_complete$responseid) %>% filter(!is.na(borough))

survey_data_segmented <- completed_subset %>%
  mutate(date = as.Date(recordeddate)) %>%   # Convert timestamp to date
  group_by(date) %>%                     # Group by date
  mutate(segment = ceiling(row_number()/n()*5))  # Create 5 segments based on row number


survey_data_sampled <- survey_data_segmented %>%
  group_by(segment) %>%
  group_split() %>%
  lapply(function(x) slice_sample(x, n = 20)) %>%
  bind_rows()

write_excel_csv(survey_data_sampled, glue::glue("../data/output/validation_sample.csv"))
```


#This should be 100%
```{r}
lapply(select_if(wrangled, labelled::is.labelled), function(col) {
  label_values <- sort(as.integer(attributes(col)$labels))
  actual_values <- as.integer(sort(unique(col)))
  result <- all(actual_values %in% label_values)
  #result <- all.equal(label_values, actual_values)
  return(result)
}) %>% unlist %>% mean
```
#Two problematic columns: pol_local, decade
```{r}
wrangled$pol_local[wrangled$pol_local == 6] <- NA
print(attributes(wrangled$decade)$labels)
print(table(wrangled$decade))
wrangled$decade[wrangled$decade == 0] <- NA
print(attributes(wrangled$decade)$labels)
print(table(wrangled$decade))
```

```{r}
lapply(select_if(wrangled, labelled::is.labelled), function(col) {
  label_values <- sort(as.integer(attributes(col)$labels))
  actual_values <- as.integer(sort(unique(col)))
  result <- all(actual_values %in% label_values)
  #result <- all.equal(label_values, actual_values)
  return(result)
}) %>% unlist %>% mean
```

#Incorporate criteria to include in validation check: all demo's, matrices, and modules completed.
```{r echo=TRUE}
#excluded <- wrangled %>% mutate(demographic_na = rowSums(is.na(select(., (c(15,17,8,14,41)))))) %>% filter(demographic_na == 0) %>% select(.,(c(1,2,15,17,8,14,41)))
#write_excel_csv(excluded, glue::glue("excluded.csv"))
wrangled$age[wrangled$age == "null"] <- NA
wrangled$race[wrangled$race == "NA"] <- NA
wrangled <- wrangled %>% mutate(demographic_na = rowSums(is.na(select(., (c(15,17,8,14,41)))))) %>% filter(demographic_na == 0)
wrangled <- wrangled %>% mutate(policy_na = rowSums(is.na(select(., 42:390)))) #%>% filter(policy_na < 347)

```

#Remove test responses from CS team that were tests
```{r}
#remove Brendan
wrangled <- filter(wrangled, email != "b.mapes@columbia.edu" | is.na(email))

#remove Ansa
wrangled <- filter(wrangled, email != "suk2107@columbia.edu" | is.na(email))

#remove Steph
wrangled <- filter(wrangled, email != "stephaniefox1016@gmail.com" | is.na(email))

#remove other tests 
wrangled <- filter(wrangled, email != "ssss@testing.com" | is.na(email))

wrangled <- filter(wrangled, email != "kd@kd.com" | is.na(email))
                     
wrangled <- filter(wrangled, email != "test@test.com" | is.na(email))
                     
wrangled <- filter(wrangled, email !=	"d@aasdfasdfs.com" | is.na(email))
                     
wrangled <- filter(wrangled, email != 	"kf2271@columbia.edu" | is.na(email))

```


#Apply Weights
```{r}
weighted <- wrangled %>% count(race_census) %>%
  filter(!is.na(race_census)) %>% mutate(actual = n/sum(n)) %>%
  left_join(census, by = c("race_census" = "label")) %>%
  select(-count, -race) %>%
  mutate(`target/actual` = glue::glue("{target}/{actual}"),
         weight = target/actual,
         weight = labelled(weight, setNames(weight, race_census))) %>%
  arrange(weight)
```


Only to be applied once the survey is complete (missing race_census_ind respondents so commenting that out for now)
```{r}
wrangled <- wrangled %>%
  left_join(select(weighted, race_census, weight), by = c("race_census")) %>%
  fastDummies::dummy_cols("race_census", ignore_na = TRUE) %>%
  rename(race_census_his_lat = "race_census_hispanic or latinx",
         race_census_twomore = "race_census_two or more races",
         race_census_black = "race_census_black or african american",
         #race_census_ind ="race_census_indigenous american / first nations (including american indian or alaska native)",
         race_census_haw = "race_census_native hawaiian or pacific islander",
         race_census_white = "race_census_white (non-hispanic or latinx)"
         )
```


#Save wrangled dataset
```{r}
# update if folder structure changes
# data
today <- gsub("-", "", Sys.Date())
write_excel_csv(weighted, file = "../data/processed/weighted.csv")
write_dta(wrangled %>% mutate(weight = as.numeric(weight)),
          path = paste0("../data/output/wrangled.dta"))
saveRDS(wrangled, file = "../data/output/wrangled.rds")
write_excel_csv(wrangled, file = "../data/output/wrangled.csv")

# codebook
codebook <- make_codebook(wrangled) %>% arrange(as.integer(str_extract(q, "(?<=q)[[:digit:]]{1,2}")))
View(codebook)
getwd()
write_excel_csv(codebook, glue::glue("../data/output/codebook.csv"))

```


# Other validation
```{r}
dim(wrangled)
final_clean %>%
  filter(responseid == "r_2xdu5ggf7umy0f7") %>%
  filter(completion >= min_completion,
         duration >= min_duration,
         q2 == 1,
         q5 > 17,
         borough != "long island")
#completion threshold off/on switch
responseids <- final_clean %>% filter(#is.na(q5),
                       is.na(borough),
                       completion >= min_completion,
                       duration >= min_duration) %>% pull(responseid)

survey %>% filter(responseid %in% responseids)
final_clean %>% filter(responseid %in% responseids) %>% mutate_if(is.labelled, labelled::to_character)
```
